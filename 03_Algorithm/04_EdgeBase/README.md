# 边缘检测

**概念**
- 边缘检测是图像处理和计算机视觉中的基本问题
- 目的是标识数字图像中亮度变化明显的点
- 大多数时候图像的边缘可以承载大部分的信息
- 提取边缘可以去除很多的干扰信息，提高数据处理的效率
  
**边缘的特征**

- 边缘是图像强度 (`这里所说的强度的核心指标是图像的亮度`) 函数中快速变化的地方

**图像的偏导**
- 将微积分中的求导原理迁移到图像上得到图像上一点的导数分为两种情况
- 如图像`在x方向`的导数就是右边相邻像素与该像素自身的差值，`y方向同理`
- 用卷积核描述偏导，`求x方向的偏导` 即是使用一个 `[-1, 1]` 的卷积核去和原图像做卷积操作即可，`y方向同理`
## 有限差分滤波器（卷积核）
### Roberts 算子
- 是一种最简单的算子，利用局部差分算子寻找边缘的算子。采用对角线方向相邻两像素之差近似梯度幅值检测边缘
- 特点是检测垂直/水平边缘的效果好于斜向边缘（这里的斜向边缘的意思是 `非正负45°的图像边缘` ），主要擅长 `增强正负45°的图像边缘` ，定位精度高，对噪声敏感，无法抑制噪声的影响
- 算子的模板分为水平方向和垂直方向，`dx = [[-1, 0], [0, 1]]` || `dy = [[0, -1], [1, 0]]`
### Prewitt 算子
- 是一种一阶微分算子的边缘检测，利用像素点上下、左右邻点的灰度差，在边缘处达到极值检测边缘，去掉部分伪边缘，对噪声具有平滑作用
- Prewitt 算子适合用来设别噪声较多、灰度渐变的图像
- `dx = [[1, 0, -1], [1, 0, -1], [1, 0, -1]]`
- `dy = [[-1, -1, -1], [0, 0, 0], [1, 1, 1]]`
### Sobel 算子
- 是一种用于边缘检测的离散微分算子，它结合了高斯平滑和微分求导。
- Sobel 算子在 Prewitt 算子的基础上增加了权重的概念，`认为相邻点的距离远近对当前像素点的影响是不同的，距离越近的点应对当前像素的影响越大`，从而实现图像锐化并突出边缘轮廓
- `dx = [[1, 0, -1], [2, 0, -2], [1, 0, -1]]`
- `dy = [[-1, -2, -1], [0, 0, 0], [1, 2, 1]]`
#### OpenCV 的Sobel实现
```python
def test_sobel():
    img = cv2.imread('00_templates/guazi.png', cv2.COLOR_BAYER_BG2GRAY)
    cv2.imshow('guazi', img)

    x_grad = cv2.Sobel(img, cv2.CV_32F, 1, 0)
    y_grad = cv2.Sobel(img, cv2.CV_32F, 0, 1)

    x_grad = cv2.convertScaleAbs(x_grad)
    cv2.imshow('x_grad', x_grad)

    y_grad = cv2.convertScaleAbs(y_grad)
    cv2.imshow('y_grad', y_grad)

    x_y = cv2.add(x_grad, y_grad, dtype=cv2.CV_16S)
    x_y = cv2.convertScaleAbs(x_y)
    cv2.imshow('x_y', x_y)
    
    cv2.waitKey(0)
```
- `x_y = cv2.convertScaleAbs(x_y)` 这一步的话不仅仅只有求绝对值的功能，还可以具有**将现有类型转化成 uint8 来显示图像的功能**
### 图像梯度


